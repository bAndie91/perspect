#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

# what does this script do?
# - display the image file given in cli argument in a window
# - let you select 4 coordinates with left mouse button
# - you can move an already pinned point by clicking again so then the closes point will be moved over
# - remove a pin point by right-clicking nearby
# - middle-click redraws the helper quadrangle
#
# KEYS
#
# F1 - perspective correction (distort) and crop, then open resulting image in gPicView
# F2 - crop around on bounding box, then open with gPicView
# F3 - rotate the image so the drawn line segment (pin 2 points down only, not 4) to be horizontal
# F4 - rotate the image so the drawn line segment (pin 2 points down only, not 4) to be vertical
# ESC - close
#
# HINTS
#
# images are not scaled, but displayed at the original size, so
# a window manager which supports Alt-dragging and window regions being out of the screen
# is recommended to work on large images.

import sys
import os
import gtk
import subprocess
import tempfile
import glib
import pyexiv2
import math


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

class EventImage(gtk.EventBox):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.image = gtk.Image()
		self.add(self.image)
	def clear(self):
		return self.image.clear()
	def set_from_pixbuf(self, *args):
		return self.image.set_from_pixbuf(*args)
	def set_from_file(self, *args):
		return self.image.set_from_file(*args)
	def set_from_file_at_size(self, path, w, h):
		pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(path, w, h)
		self.image.set_from_pixbuf(pixbuf)
	def set_size_request(self, *args):
		return self.image.set_size_request(*args)
	@property
	def size(self):
		pb = self.image.get_pixbuf()
		return pb.get_width(), pb.get_height()
	@property
	def width(self):
		return self.size[0]
	@property
	def height(self):
		return self.size[1]
	@property
	def pixbuf(self):
		return self.image.get_pixbuf()
	@pixbuf.setter
	def pixbuf(self, pb):
		self.image.set_from_pixbuf(pb)
	def redraw(self):
		self.pixbuf = self.pixbuf

class Coordinate(object):
	def __init__(self, x, y):
		self.x = x
		self.y = y
	def __str__(self):
		return '%d,%d' % (self.x, self.y)

def on_clicked(widget, event):
	x = int(min(max(0, event.x), image.width))
	y = int(min(max(0, event.y), image.height))
	
	if event.button == 1:
		if all([c.x!=x and c.y!=y for c in coordinates]):
			if len(coordinates) >= 4:
				remove_closest_point(x, y)
			coordinates.append(Coordinate(x, y))
	elif event.button == 3:
		remove_closest_point(x, y)
	update_statusline()

def remove_closest_point(x, y):
	if len(coordinates) > 0:
		distances = map(lambda c: {'d': (abs(c.x - x)**2 + abs(c.y - y)**2)**0.5, 'p': c}, coordinates)
		closest = sorted(distances, key=lambda x: x['d'])[0]['p']
		coordinates.remove(closest)

def update_statusline():
	topleft, bottomleft, topright, bottomright = get_quadrangle_points()
	#text = '%d:%d; %d:%d; %d:%d; %d:%d' % (topleft.x, topleft.y, topright.x, topright.y, bottomright.x, bottomright.y, bottomleft.x, bottomleft.y)
	text = '; '.join(map(lambda c: "%d:%d"%(c.x, c.y), filter(lambda c: c.x >= 0, [topleft, topright, bottomright, bottomleft])))
	if len(coordinates) > 1:
		text += '; %0.2f째' % get_linesegment_angle(coordinates[0], coordinates[1])
	
	statusline.set_text(text)
	
	image.redraw()
	glib.idle_add(draw_cage, priority=glib.PRIORITY_DEFAULT_IDLE)

def draw_cage():
	topleft, bottomleft, topright, bottomright = get_quadrangle_points()
	real_points = filter(lambda c: c.x >= 0, [topleft, topright, bottomright, bottomleft])
	drawable = image.window
	gc = gtk.gdk.GC(drawable)
	gc.set_rgb_fg_color(gtk.gdk.color_parse('red'))
	drawable.draw_lines(gc, [(c.x, c.y) for c in make_polygon(real_points)])

def make_polygon(points):
	for i in range(len(points)):
		yield points[i-1]
		yield points[i]

def get_quadrangle_points():
	points_left_to_right = sorted(coordinates, cmp=lambda a, b: cmp(a.x, b.x))
	while len(points_left_to_right) < 4: points_left_to_right.append(Coordinate(-1, -1))
	src_left_points  = points_left_to_right[0:2]
	src_right_points = points_left_to_right[-2:]
	src_topleft     = sorted(src_left_points,  cmp=lambda a, b: cmp(a.y, b.y))[0]
	src_bottomleft  = sorted(src_left_points,  cmp=lambda a, b: cmp(a.y, b.y))[1]
	src_topright    = sorted(src_right_points, cmp=lambda a, b: cmp(a.y, b.y))[0]
	src_bottomright = sorted(src_right_points, cmp=lambda a, b: cmp(a.y, b.y))[1]
	return src_topleft, src_bottomleft, src_topright, src_bottomright

def do_magick(distortion=True, crop=True):
	src_topleft, src_bottomleft, src_topright, src_bottomright = get_quadrangle_points()
	leftmost   = sorted(coordinates, cmp=lambda a, b: cmp(a.x, b.x))[0].x
	topmost    = sorted(coordinates, cmp=lambda a, b: cmp(a.y, b.y))[0].y
	rightmost  = sorted(coordinates, cmp=lambda a, b: cmp(a.x, b.x))[-1].x
	bottommost = sorted(coordinates, cmp=lambda a, b: cmp(a.y, b.y))[-1].y
	trg_topleft     = Coordinate(leftmost, topmost)
	trg_bottomleft  = Coordinate(leftmost, bottommost)
	trg_topright    = Coordinate(rightmost, topmost)
	trg_bottomright = Coordinate(rightmost, bottommost)
	coordinatepairs = ' '.join(map(str, [
		src_topleft, trg_topleft, 
		src_topright, trg_topright,
		src_bottomright, trg_bottomright,
		src_bottomleft, trg_bottomleft,
		]))
	cmd = ["convert", SOURCEFILE, "-auto-orient"]
	if distortion:
		cmd.extend(["-matte", "-virtual-pixel", "transparent", "-distort", "Perspective", coordinatepairs])
	if crop:
		cmd.extend(["-crop", "%dx%d+%d+%d"%(rightmost-leftmost, bottommost-topmost, leftmost, topmost), "+repage"])
	run_command_background(cmd)

def run_command_background(cmd):
	_fd, outfile = tempfile.mkstemp(suffix='.jpg')
	cmd.extend([outfile])
	# start convert and display in detached background process
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(3, 255)
		pid2 = os.fork()
		if pid2 == 0:
			print cmd
			err = subprocess.call(cmd, stdout=sys.stdout, stderr=sys.stderr)
			if err != 0:
				sys.stderr.write("imagemagick error: %d\n" % err)
			if err == 0:
				# TODO: open in perspect
				# TODO: and add 'Save' and 'open in gPicView' function
				subprocess.Popen(["gpicview", outfile], stdout=sys.stdout, stderr=sys.stderr)
			os._exit(err)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

def do_distortion_and_crop(*_):
	do_magick(distortion=True, crop=True)

def do_crop(*_):
	do_magick(distortion=False, crop=True)

def get_linesegment_angle(A, B):
	tan = float(abs(A.x - B.x)) / float(abs(A.y - B.y))
	return math.degrees(math.atan(tan))

def do_rotation_horizontal(*_):
	angle = get_linesegment_angle(coordinates[0], coordinates[1])
	do_rotation(angle - 90)

def do_rotation_vertical(*_):
	angle = get_linesegment_angle(coordinates[0], coordinates[1])
	do_rotation(angle)

def do_rotation(angle):
	cmd = ["convert", SOURCEFILE, "-auto-orient", "-rotate", str(angle)]
	run_command_background(cmd)

def exif_transforms():
	# transform the image on screen according to the file's EXIF metadata
	metadata = pyexiv2.ImageMetadata(SOURCEFILE)
	metadata.read()
	if 'Exif.Image.Orientation' in metadata.exif_keys:
		orientation = metadata['Exif.Image.Orientation'].value
		# flip-flop:
		if orientation in [2, 4]:
			# mirror on the vertical axis
			image.pixbuf = image.pixbuf.flip(horizontal=False)
			orientation -= 1
		elif orientation in [5, 7]:
			# mirror on the horizontal axis
			image.pixbuf = image.pixbuf.flip(horizontal=True)
			orientation += 1
		# rotation:
		rotation = None
		if orientation == 6:
			# rotate 90째 CW
			rotation = gtk.gdk.PIXBUF_ROTATE_CLOCKWISE
		elif orientation == 3:
			# rotate 180째 CW
			rotation = gtk.gdk.PIXBUF_ROTATE_UPSIDEDOWN
		elif orientation == 8:
			# rotate 270째 CW
			rotation = gtk.gdk.PIXBUF_ROTATE_COUNTERCLOCKWISE
		if rotation is not None:
			image.pixbuf = image.pixbuf.rotate_simple(rotation)



window = gtk.Window()
window.set_title("Perspective correction")
window.connect('delete-event', lambda *x: gtk.main_quit())
add_key_binding(window, 'Escape', gtk.main_quit)
add_key_binding(window, 'F1', do_distortion_and_crop)
add_key_binding(window, 'F2', do_crop)
add_key_binding(window, 'F3', do_rotation_horizontal)
add_key_binding(window, 'F4', do_rotation_vertical)

box1 = gtk.VBox()
statusline = gtk.Label()
statusline.set_alignment(0, 0)


SOURCEFILE = sys.argv[1]
window.set_title(window.get_title() + ": " + SOURCEFILE)

image = EventImage()
image.set_from_file(SOURCEFILE)
image.connect('button-release-event', on_clicked)
exif_transforms()

coordinates = []


window.add(box1)
box1.pack_start(image, True, True)
box1.pack_start(statusline, False, True)

window.show_all()
window.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.CROSSHAIR))
gtk.main()
